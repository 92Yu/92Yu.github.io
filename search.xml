<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[信标(Beacon)--数据上传好帮手]]></title>
    <url>%2F2021%2F06%2F30%2F%E4%BF%A1%E6%A0%87-Beacon-%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E5%A5%BD%E5%B8%AE%E6%89%8B%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 前言日常开发过程中，难免会遇到日志记录相关的需求。有一种需求是需要记录用户在页面停留时间，自然而然的会想到方案：当页面加载时，我们会记录下时间，当用户离开页面时，我们将发送开始时间和当前时间到服务器。那么我们会使用什么方法来上传信息到服务器呢？通常是发送一个GET请求（一般是一个带有统计信息的图片请求），使统计服务器获取到数据。这种方式有以下几个弊端：1.当页面关闭时，发送的统计请求可能不会成功，导致统计数据丢失。2.通常为了解决关闭页面的统计数据丢失问题，会发起一个同步的请求，这样会阻塞页面的卸载。3.GET请求通常有长度限制，可携带的数据量有限，并且一般只能携带文本信息。 那么如何解决上述问题呢？我们引入今天的主角–Beacon API. 什么是Beacon APIMDN 是这样描述的 The Beacon API is used to send an asynchronous and non-blocking request to a web server. The request does not expect a response. Unlike requests made using XMLHttpRequest or the Fetch API, the browser guarantees to initiate beacon requests before the page is unloaded and to run them to completion. 翻译成人话就是 BeaconAPI 用于向 Web 服务器发送异步和非阻塞请求。该请求不期望得到响应。与使用XMLHttpRequest或Fetch API发出的请求不同，浏览器保证在页面卸载之前启动信标请求并运行它们直到完成。 重点是 不期望得到响应，这意味着我们无需等待响应的过程，只需要发送就好了。 Beacon API 使用方法Beacon 定义了一个方法：navigator.sendBeacon(url, data);这个接口定义了2个参数，url和要在请求中发送的数据data。其中数据参数是可选的，并且它的类型可以是ArrayBufferView，Blob，DOMString，或FormData。如果浏览器成功排队发送请求，该方法返回true；否则，它返回false。 需要注意的是：这个方法并不是适用所有的浏览器，因此我们需要在使用前判断当前环境是否支持。12345if (navigator.sendBeacon) &#123; // Beacon API&#125; else &#123; // fallback sync XHR / Fetch API / Axios&#125; 常见的浏览器兼容情况如图 示例12345678910111213141516let logVisit = function() &#123; // 测试我们拥有 Beacon 支持 if (!navigator.sendBeacon) return true; // 数据发送的URL的例子 let url = &apos;/api/log-visit&apos;; // 要发送的数据 let data = new FormData(); data.append(&apos;start&apos;, startTime); data.append(&apos;end&apos;, performance.now()); data.append(&apos;url&apos;, document.URL); // 发送 navigator.sendBeacon(url, data);&#125;; 注意，如果没有 Beacon 支持，我们返回 true ，假装一切正常。返回 false 会取消事件并且终止页面卸载。那给用户的感觉就是页面卡住了。 统计数据上报的优雅姿势这里我们借鉴一片优秀文章的总结：具体文章戳这里]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript中readonly和const]]></title>
    <url>%2F2020%2F12%2F07%2FTypeScript%E4%B8%ADreadonly%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 readonly 属性修饰符 readonly 是一个属性(property) 修饰符，顾名思义，在 TypeScript 中它可以把一个属性变成只读的。我们可以在 class/interface/type 定义中使用它，也可以用来定义一个函数的参数。既然是只读的意味着一旦定义了就不能再修改，所以这些属性必须在声明的时候或者在类中对它进行初始化。 TypeScript 类型系统允许你在一个 function 里使用 readonly 来标记参数属性。它能让你以一种更安全的方式工作（不可预期的改变通常会带来很糟糕的后果）。12345678function foo(config: &#123; readonly bar: number, readonly bas: number &#125;) &#123; // ..&#125;const config = &#123; bar: 123, bas: 123 &#125;;foo(config);// 现在你能够确保 'config' 不能够被改变了 当然，你也可以在 interface 和 type 里使用 readonly：123456789101112131415161718// typetype Foo = &#123; readonly bar: number; readonly bas: number;&#125;;// 初始化const foo: Foo = &#123; bar: 123, bas: 456 &#125;;// 不能被改变foo.bar = 456; // Error: foo.bar 为仅读属性// interfaceinterface Foo &#123; readonly [x: number]: number;&#125;// 使用const foo: Foo = &#123; 0: 123, 2: 345 &#125;;console.log(foo[0]); // ok（读取）foo[0] = 456; // Error: 属性只读 你也能指定一个类的属性为只读，然后在声明时或者构造函数中初始化它们，如下所示：1234567class Foo &#123; readonly bar = 1; // OK readonly baz: string; constructor() &#123; this.baz = 'hello'; // OK &#125;&#125; Readonly 映射类型 对于每个属性都要写一个 readonly 的做法实在是不够优雅。作为一个推崇 Less is more (lan duo) 的人，能够少写一点就尽量少写。有没有一种方法可以一键给所有属性添加 readonly 定义呢？有的，官方标准库 lib.es5.d.ts 提供了一个方法 Readonly 把对象上所有属性变为只读。 123456789101112type Foo = &#123; bar: number; bas: number;&#125;;type FooReadonly = Readonly&lt;Foo&gt;;const foo: Foo = &#123; bar: 123, bas: 456 &#125;;const fooReadonly: FooReadonly = &#123; bar: 123, bas: 456 &#125;;foo.bar = 456; // okfooReadonly.bar = 456; // Error: bar 属性只读 NOTE: 需要注意的是，Readonly 只对它当前修饰的属性有效，并不会对嵌套属性产生影响:123456789101112131415161718192021interface foo &#123; readonly bar: string; readonly baz: &#123; hoo: number; &#125;&#125;const fuu: foo = &#123; bar: 'bar', baz: &#123; hoo: 1 &#125;&#125;fuu.baz = &#123; hoo: 2 &#125; // ❌ fuu.baz.hoo = 3; // ✅// 要在嵌套里面再使用 Readonly&lt;T&gt;interface foo &#123; readonly bar: string; readonly baz: Readonly&lt;&#123; hoo: number; &#125;&gt;&#125; 与 const 区别const: 用于变量； 变量不能重新赋值给其他任何事物 readonly: 用于属性 用于别名，可以修改属性 eg:1234const foo = 123; // 变量let bar: &#123; readonly bar: number; // 属性&#125;; — end —]]></content>
      <tags>
        <tag>前端</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法（精简版）]]></title>
    <url>%2F2020%2F11%2F24%2FMarkdown%20%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[节选自Markdown官方文档 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 标题层级 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：This is an H1=============This is an H2-------------任何数量的 = 和 - 都可以有效果。类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：# 这是 H1## 这是 H2###### 这是 H6你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：# 这是 H1 ### 这是 H2 ##### 这是 H3 ###### 无序列表 可以使用+，-，*做为列表的项目标记,列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 加粗 形如：**test**, test 斜体 形如：*test*, test 插入链接 1. 形如：[xxx](http://www.baidu.com) , xxx 2. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记,This is [an example][id] reference-style link,接着，在文件的任意处，你可以把这个标记的链接内容定义出来,[id]: http://example.com/ &quot;Optional Title Here&quot; This is an example reference-style link. 插入图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 1.一个惊叹号 ! 2.接着一个方括号，里面放上图片的替代文字 3.接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 eg: &lt;img src=&quot;/blog_pic/HeadPic.jpg&quot; height=&quot;200&quot; width=&quot;200&quot; /&gt; 插入代码 要在 Markdown 中建立代码区块很简单，只要简单地使用三个反引号即可,如下例所示 this is normal part。 ``` this is code part。 ``` 表示为： this is normal part。 1this is code part。 要想在文字中见插入简短的代码，只需在代码的开始和结束各使用单个反引号即可。 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠：\*literal asterisks\*,表示为*literal asterisks*Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 符号 意义 \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocosCreator优化DrawCall漫谈]]></title>
    <url>%2F2020%2F08%2F07%2FCocosCreator%E4%BC%98%E5%8C%96%E4%B9%8BDrawCall%E6%BC%AB%E8%B0%88%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 前言在游戏开发中，DrawCall 作为一个非常重要的性能指标，直接影响游戏的整体性能表现。无论是 Cocos Creator、Unity、Unreal 还是其他游戏引擎，只要说到游戏性能优化，DrawCall 都是绝对少不了的一项。本文将会介绍什么是 DrawCall，为什么要减少 DrawCall 以及在 Cocos Creator 项目中如何减少 DrawCall 来提升游戏性能。 正文什么是 DrawCall DrawCall就是CPU调用图形库（比如DirectX或OpenGL）的图形绘制接口，来命令GPU进行渲染的操作。 DrawCall 是如何影响性能的呢？ 先举个栗子：http形式从服务器拉取1024个大小1kb的文件和单个大小为1M的文件，哪个耗时更短？答：肯定是拉取单个1M的更快。原因就是每个请求之前，http 都需要做许多的准备工作来保证文件能够正常传输。而正是这些额外工作，造成了很多时间和性能开销。 而每一次绘制CPU都要调用DrawCall，而在调动DrawCall前，CPU还要进行很多准备工作：检测渲染状态、提交渲染所需要的数据、提交渲染所需要的状态。而GPU本身具有很强大的计算能力，可以很快就处理完渲染任务。一般来说，绘制 100 个三角形和绘制 1000 个三角形所消耗的时间没差多少。但是，当 DrawCall 过多，CPU就会很多额外开销用于准备工作，CPU本身负载，而这时GPU可能闲置了。 也就是说，正是因为每次渲染前，CPU 都需要做一系列准备工作，而 CPU 的每一次内存显存读写、数据处理和渲染状态切换都会带来一定的性能和时间消耗，积少成多，而 GPU 大部分时间都在摸鱼。所以才造成了我们认知中的，DrawCall 数量过多导致了卡顿 如何减少 DrawCall如上所说，我们可以通过一次多给 CPU 分配点工作，让一次渲染的内容多一些，减少分配次数，来达到我们的目的。话是这么说，可是我们应该怎么实际操作呢？往下看 针对图片资源静态合图就是讲碎图整合成一张大图，即我们常说的 打图集。但是图集也不是随便打的，并不是一张大图容纳越多的碎图越好。这里面也是有一定的门道的。 尽量将处于同一界面（UI）下的相邻且渲染状态相同的碎图打包成图集 对于Creator来说，在游戏运行时引擎是按照节点层级顺序从上往下由浅到深进行渲染的，理论上 每渲染一张图像（文本最终也是图像）都需要一次 DrawCall。渲染状态是指：纹理状态（预乘、循环模式和过滤模式）或 Material（材质）、Blend（混合模式）等等，所以使用自定义 Shader 也会打断合批 所以 相邻且渲染状态相同 是关键点。tip: 不建议任何图片资源的尺寸超过2048*2048，否则可能会出现加载相关的问题。 下面介绍2种打图集的方式 自动图集资源（Auto Atlas）利用 Cocos Creator 内置的自动图集资源来将碎图打包成图集。在项目构建时，编辑器会将所有自动图集资源所在文件夹下的所有符合要求的图像分别根据配置打包成一个或多个图集。自动图集资源使用起来很灵活，编辑器在打包图集时会自动递归子目录，若子目录下也有自动图集资源（即 .pac 文件）则会跳过该目录，所以我们可以对同一目录下的不同部分的碎图配置不同的参数。 关于自动图集的几点建议 合理控制图集最大尺寸，避免单个图像加载时间过长。 尺寸太大的图像没有必要打进图集（如背景图）。 善用九宫格（Sliced）可以节省很多空间（这一点需要美术大佬配合）。 间距保持默认的 2 并保持勾选扩边选项，避免图像裁剪错误和出现黑边的情况。 勾选不包含未被引用资源选项，自动排除没有用到的图像以节省空间（该选项预览时无效）。 开发时预览图集，根据结果进行调整，以达到最好的优化效果。 TexturePacker 使用 TexturePacker 打包图集时需要注意配置「形状填充（Shape Padding，对应 Auto Atlas 中的间距）」，避免某张图像出现相邻图像的像素的情况。 对比一下Auto Atlas Cocos Creator 内置，方便 功能不多但是该有的都有 项目构建时才生成图集，开发时任意修改无压力 图集尺寸在生成时自适应，节省空间 支持自动纹理压缩 TexturePacker 第三方软件需自行安装，不够方便 收费功能很多很专业但是基本用不着，免费功能也够用 先生成图集再使用，更换图像又要重新生成图集 尺寸固定需要自己设置 不支持自动纹理压缩 动态合图Creator 官方说明： Cocos Creator 提供了在项目构建时的静态合图方法 —— 「自动合图」（Auto Atlas）。但是当项目日益壮大的时候贴图会变得非常多，很难将贴图打包到一张大贴图中，这时静态合图就比较难以满足降低 DrawCall 的需求。所以 Cocos Creator 在 v2.0 中加入了 「动态合图」（Dynamic Atlas）的功能，它能在项目运行时动态的将贴图合并到一张大贴图中。当渲染一张贴图的时候，动态合图系统会自动检测这张贴图是否已经被合并到了图集（图片集合）中，如果没有，并且此贴图又符合动态合图的条件，就会将此贴图合并到图集中。动态合图官方文档：https://docs.cocos.com/creator/manual/zh/advanced-topics/dynamic-atlas.html 动态图集有2个限制： 动态图集尺寸最大是 2048 * 2048 碎图的尺寸默认不能超过 512，可通过 API 进行修改：cc.dynamicAtlasManager.maxFrameSize = 512 tips: 启用动态合图会增大内存消耗，不同平台占用内存不一致。小游戏和原生平台默认禁止动态合图。可以通过 api 自行开启：cc.macro.CLEANUP_IMAGE_CACHE = false; cc.dynamicAtlasManager.enabled = true;还需要保证纹理的 Premulyiply Alpha（预乘）、Wrap Mode（循环模式） 和 Filter Mode（过滤模式） 等信息与动态图集一致才能够动态合批。 另外，静态图集也能参与动态合图，只要满足动态合图的要求即可。tip1: 自动图集资源（Auto Atlas）需要在其属性检查器面板中开启 Texture 栏下的 Packable 选项，该选项默认是禁用的。tip2: 精灵（Sprite）也是需要开启 Packable 选项才能动态合图。该选项默认是开启的。tip3: 如果要使用了 shader ，那么需要禁用该精灵的 Packable 选项。 针对 Label位图字体（BMFont）在 Creator 中使用系统字体或 TTF 字体的 Label 会打断渲染合批，特别是 Label 和 Sprite 层叠交错的情况，每一个 Label 都会打断合批增加一个 DrawCall。 因此建议使用 BMFont 来代替 TTF 或系统字体，并且将 BMFont 与 UI 碎图打包到同一图集中（或「开启动态合图」），可以免除大部分文本导致的 DrawCall增加。 文本缓存模式（Cache Mode）Creator 2.0.9 版本在 Label 组件上增加了 Cache Mode 选项，来解决系统字体和 TTF 字体带来的性能问题。CacheMode有三种选项： NONE（默认）每一个 Label 都会生成为一张单独的位图，且不会参与动态合图，所以每一个 Label 都会打断渲染合批 BITMAP开启 BITMAP 模式后，文本同样会生成为一张位图，但是只要符合动态合图要求就可以参与动态合图，和周围的精灵合并 DrawCall 。 一定要注意 BITMAP 模式只适用于不频繁更改的文本，否则内存会爆炸。 CHAR开启 CHAR 模式后，引擎会将该 Label 中出现的所有字符缓存到一张全局共享的位图中，相当于是生成了一个 BMFont 。适用于文本频繁更改的情况，对性能和内存最友好。tip： 该模式 只能用于字体样式和字号固定，并且不会频繁出现巨量未使用过的字符 的 Label。因为共享位图的最大尺寸为 2048*2048，占满了之后就没办法再渲染新的字符，需要切换场景才会清除共享位图。 总结：对于大量频繁更改的文本，使用 CHAR 模式带来的性能提升是非常明显的。 同时 CHAR 模式的局限也很明显，一般用于场景中出现大量数字文本，类似于经验值增加、血量减少之类的特效的情况 必经之路–调整UI层级顺序 原则： 分离图像节点和文本节点 文本使用 BMFont 或 Cache Mode 选项，尽量出现避免文本打断渲染合批的情况 FBI WARNING: 一个 Mask 组件及其控制的渲染节点，需要至少三次 Draw call。第一次开启模板测试并调用一次 Draw call，刷新模板缓冲。第二次绘制对需要通过模板测试的区域进行设置。第三次再进行实际的子节点内容绘制，绘制结束再关闭模板测试。因此 使用 Mask 组件就无法与其他相邻节点进行批次处理 ，但是 Mask 组件内部的连续节点在满足合并规则的情况下还是会进行合批。 总结 改变渲染状态会打断渲染合批，例如改变纹理状态（预乘、循环模式和过滤模式）或改变 Material（材质）、Blend（混合模式）等等，所以使用自定义 Shader 也会打断合批。 图集默认不参与动态合图，手动开启自动图集资源的 Packable 选项后如果最终图集符合动态合图要求也可以参与动态合图。 纹理开启 Packable 选项参与动态合图后无法使用自定义 Shader，因为动态合图会修改原始贴图的 UV 坐标。 使用 Cache Mode 的 BITMAP 模式需要注意内存情况，CHAR 模式需要注意文本内容不宜过多。 在 Cocos Creator 2.0.7 之前的版本中，改变节点的颜色或透明度、Sprite 组件使用九宫格（Sliced）都会打断渲染合批 以上内容整理自 CocosCreator 官方文档，点击这里查看]]></content>
      <tags>
        <tag>CocosCreator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extends和implement的区别]]></title>
    <url>%2F2019%2F12%2F18%2Fextends%E5%92%8Cimplement%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 前言最近在学习pureMVC，发现其中不少类继承的时候会写成形如export default class AppFacade extends puremvc.Facade implements puremvc.IFacade {...}的样子；最初我的理解中，extends和implement都是继承的意思，但是又一想，都是继承完全可以写成export default class AppFacade extends puremvc.Facade puremvc.IFacade {...}那么问题来了，extends和implement的区别是什么呢？ 假设假如我有一个干净的抽象类A123abstract class A &#123; abstract m(): void;&#125; 在继承(extends)方面，就像C#或者java里面那样，我可以像下面这样来继承这个抽象类：1234//TypeScriptclass B extends A&#123;&#125; 但是在实现方面（implement），在TypeScript中也可以去implement一个类：123class C implements A &#123; m(): void &#123; &#125;&#125; 那么问题来了：类B和类C在行为上有什么不同？我该如何选择？ 解答implements关键字将类A当作一个接口，这意味着类C必须去实现定义在A中的所有方法，无论这些方法是否在类A中有没有默认的实现。同时，也不用在类C中定义super方法。而就像是extends关键字本身所表达的意思一样，你只需要实现类A中定义的虚方法，并且关于super的调用也会有效。我想在抽象方法的情况下，这并没有什么区别。但是很少有只使用抽象方法的类，如果只使用抽象方法，最好将其转换为接口。 回到前言中的例子，Facade是一个基类，IFacade是基于Facade扩展出来的一个接口类，那么此时AppFacade具有Facade的属性，同时又必须实现IFacade中定义的方法。 —end—]]></content>
      <tags>
        <tag>前端</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让Git像SVN那样按照文件夹更新的Git SubModule]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%AE%A9Git%E5%83%8FSVN%E9%82%A3%E6%A0%B7%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%B9%E6%9B%B4%E6%96%B0%E7%9A%84Git-SubModule%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 前言最近项目出现了新的需求，需要在一个Creator框架工程中，集成多个子游戏。优点：所有游戏集中管理，避免出现一旦框架更改，所有子游戏工程需要全部改一遍痛点：如果子游戏数量过多，会导致项目工程巨大，打开编译等速度过慢目的：框架自身和各子游戏需要能够独立更新，互不影响 引用一段《Git权威指南》的话：项目的版本库在某些情况虾需要引用其他版本库中的文件，例如公司积累了一套常用的函数库，被多个项目调用，显然这个函数库的代码不能直接放到某个项目的代码中，而是要独立为一个代码库，那么其他项目要调用公共函数库该如何处理呢？分别把公共函数库的文件拷贝到各自的项目中会造成冗余，丢弃了公共函数库的维护历史，这显然不是好的方法。 Git Submodule功能刚刚开始学习可能觉得有点怪异，所以本文会把每一步的操作的命令和结果都用代码的形式展现给大家，以便更好的理解。 1. 学习Git SubModule说明：本例采用两个项目以及两个公共类库演示对submodule的操作。 1.1 创建Git SubModule示例项目1.1.1 准备环境12345C:\Users\TAL-YINGYU\Desktopλ mkdir repoC:\Users\TAL-YINGYU\Desktopλ cd repo\ 创建本地仓库：123456789101112131415C:\Users\TAL-YINGYU\Desktop\repoλ git --git-dir=lib1.git init --bareInitialized empty Git repository in C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/C:\Users\TAL-YINGYU\Desktop\repoλ git --git-dir=lib2.git init --bareInitialized empty Git repository in C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/C:\Users\TAL-YINGYU\Desktop\repoλ git --git-dir=project1.git init --bareInitialized empty Git repository in C:/Users/TAL-YINGYU/Desktop/repo/project1.git/C:\Users\TAL-YINGYU\Desktop\repoλ git --git-dir=project2.git init --bareInitialized empty Git repository in C:/Users/TAL-YINGYU/Desktop/repo/project2.git/ 初始化工作区：12345C:\Users\TAL-YINGYU\Desktopλ mkdir workSpaceLocalC:\Users\TAL-YINGYU\Desktopλ cd workSpaceLocal\ 1.1.2 初始化项目初始化project1：123456789101112131415161718192021222324252627282930313233343536C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone ..\repo\projectproject1.git\ project2.git\C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone ..\repo\project1.git\Cloning into &apos;project1&apos;...warning: You appear to have cloned an empty repository.done.C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ cd project1\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ echo &quot;project1&quot; &gt; project1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ lsproject1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git add project1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git commit -m &quot;init project1&quot;[master (root-commit) 89fcc18] init project1 1 file changed, 1 insertion(+) create mode 100644 project1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git push origin masterEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Writing objects: 100% (3/3), 227 bytes | 227.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git\ * [new branch] master -&gt; master 初始化project2：123456789101112131415161718192021222324252627282930313233343536C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone ..\repo\project2.git\Cloning into &apos;project2&apos;...warning: You appear to have cloned an empty repository.done.C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ cd project2\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ echo &quot;project2&quot; &gt; project2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ lsproject2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git add project2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git commit -m &quot;init project2&quot;[master (root-commit) fdefcbe] init project2 1 file changed, 1 insertion(+) create mode 100644 project2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git push origin masterEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Writing objects: 100% (3/3), 229 bytes | 229.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project2.git\ * [new branch] master -&gt; master 1.1.3 初始化公共类库初始化lib1：1234567891011121314151617181920212223242526272829303132C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone ..\repo\lib1.git\Cloning into &apos;lib1&apos;...warning: You appear to have cloned an empty repository.done.C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ cd lib1\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib1 (master -&gt; origin)λ echo &quot;I&apos;m lib1.&quot; &gt; lib1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib1 (master -&gt; origin)λ git add lib1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib1 (master -&gt; origin)λ git commit -m &quot;init lib1&quot;[master (root-commit) 1ffa3a9] init lib1 1 file changed, 1 insertion(+) create mode 100644 lib1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib1 (master -&gt; origin)λ git push origin masterEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Writing objects: 100% (3/3), 222 bytes | 222.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\lib1.git\ * [new branch] master -&gt; master 初始化lib2：1234567891011121314151617181920212223242526272829303132333435C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib1 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone ..\repo\lib2.git\Cloning into &apos;lib2&apos;...warning: You appear to have cloned an empty repository.done.C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ cd lib2\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib2 (master -&gt; origin)λ echo &quot;I&apos;m lib 2&quot; &gt; lib2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib2 (master -&gt; origin)λ git add lib2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib2 (master -&gt; origin)λ git commit -m &quot;init lib2&quot;C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib2 (master -&gt; origin)λ git commit -m &quot;init lib2&quot;[master (root-commit) 1f05672] init lib2 1 file changed, 1 insertion(+) create mode 100644 lib2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib2 (master -&gt; origin)λ git push origin masterEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Writing objects: 100% (3/3), 222 bytes | 222.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\lib2.git\ * [new branch] master -&gt; master 1.2 为主项目添加SubModules1.2.1 为project1添加lib1和lib21234567891011121314151617181920212223242526272829303132333435363738394041424344454647C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\lib2 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ cd project1\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git submodule add C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/Cloning into &apos;C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project1/lib1&apos;...done.warning: LF will be replaced by CRLF in .gitmodules.The file will have its original line endings in your working directoryC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git submodule add C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/Cloning into &apos;C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project1/lib2&apos;...done.warning: LF will be replaced by CRLF in .gitmodules.The file will have its original line endings in your working directoryC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ lslib1/ lib2/ project1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: .gitmodules new file: lib1 new file: lib2#看一看公共类库内容是不是刚才我们初始化的C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cat lib1\.git lib1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cat lib1\lib1-infos.md&quot;I&apos;m lib1.&quot;C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cat lib2\lib2-infos.md&quot;I&apos;m lib 2&quot; 到目前为止，我们已经使用git submodule add命令为project1添加了两个公共类库，通过查看当前状态发现添加了一个新的文件（.gitmodules）和两个问题件夹（lib1， lib2），那么.gitmodules文件是做什么用的呢？我们来看一下内容：12345678C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cat .gitmodules[submodule &quot;lib1&quot;] path = lib1 url = C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/[submodule &quot;lib2&quot;] path = lib2 url = C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/ 原来这里面存储的都是每个submodule的相关信息，知道在当前项目的位置以及远程仓库地址ok，现在我们把project1的更改提交到远程仓库123456789101112131415161718C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git commit -m &quot;add submodules[lib1,lib2] to project1&quot;[master b0389b8] add submodules[lib1,lib2] to project1 3 files changed, 8 insertions(+) create mode 100644 .gitmodules create mode 160000 lib1 create mode 160000 lib2C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git pushEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 12 threadsCompressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 449 bytes | 449.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git\ 89fcc18..b0389b8 master -&gt; master 那么问题来了，如果一个项目中已经引入了公共类库，项目组其他成员如何clone这个项目呢？ 1.3 模拟clone带有submodule的仓库模拟组员m：12345678910111213141516171819C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone ..\repo\project1.git project1-bCloning into &apos;project1-b&apos;...done.C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ lslib1/ lib2/ project1/ project1-b/ project2/C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ cd project1-b\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git submodule-1ffa3a92c147a2d09fadbc5129389cc6fd1b95cb lib1-1f05672f7ff92395fcbbe325ab2cda7405da40e8 lib2 可以看得出submodule的状态是hash码和文件目录，但是前面有一个 - 号，这表示这个子模块还没有被检出ok，我们检出project1-b的submodule12345678910111213C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git submodule initSubmodule &apos;lib1&apos; (C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/) registered for path &apos;lib1&apos;Submodule &apos;lib2&apos; (C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/) registered for path &apos;lib2&apos;C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git submodule updateCloning into &apos;C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project1-b/lib1&apos;...done.Cloning into &apos;C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project1-b/lib2&apos;...done.Submodule path &apos;lib1&apos;: checked out &apos;1ffa3a92c147a2d09fadbc5129389cc6fd1b95cb&apos;Submodule path &apos;lib2&apos;: checked out &apos;1f05672f7ff92395fcbbe325ab2cda7405da40e8&apos; 我们来看下.git/config文件的内容123456789101112131415161718192021C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ cat .git/config[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\\repo\\project1.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[submodule &quot;lib1&quot;] active = true url = C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/[submodule &quot;lib2&quot;] active = true url = C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/ 可以看到里面有最新的submodule信息我们来验证下本地项目中公共类库是否存在：1234C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ cat lib1\lib1-infos.md lib2\lib2-infos.md&quot;I&apos;m lib1.&quot;&quot;I&apos;m lib 2&quot; 1.4 修改submodule继续模拟组员m修改submodule的内容先看下当前submodule的状态1234567C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ cd lib1\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (HEAD detached at 1ffa3a9 -&gt; origin)λ git statusHEAD detached at 1ffa3a9nothing to commit, working tree clean 这个时候HEAD直接指向一个commit，Git会警告我们出现了所谓的detached HEAD现象。表示当前git状态不属于任何一个分支。 那么为什么会出现这个情况呢？ 继续往下看：git对于submodule有特殊的处理方式，在一个主项目中引入submoudle的时候，其实git做了3件事： 记录引用的仓库 记录主项目中submodule的目录位置 记录引用submodule的 commit id 在project1中push了之后，其实就是执行了更新引用的commit id，然后project1-b在clone的时候获取到了submodule的commit id，然后执行git submodule update的时候，git就根据gitlink获取submodule的commit id，最后获取submodule的文件，所以clone之后不在任何分支上，但是master分支的commit id和HEAD保持一致。 现在我们要先切换到master分支：12345C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (HEAD detached at 1ffa3a9 -&gt; origin)λ git checkout masterPrevious HEAD position was 1ffa3a9 init lib1Switched to branch &apos;master&apos;Your branch is up to date with &apos;origin/master&apos;. 组员m修改lib1：123456789101112131415C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (master -&gt; origin)λ cat lib1-infos.md&quot;I&apos;m lib1.&quot;C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (master -&gt; origin)λ echo &quot;modified by developer m&quot; &gt; lib1-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (master -&gt; origin)λ cat lib1-infos.md&quot;modified by developer m&quot;C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (master -&gt; origin)λ git commit -a -m &quot;modify lib1-infos.md by developer m&quot;[master f220249] modify lib1-infos.md by developer m 1 file changed, 1 insertion(+), 1 deletion(-) 在主项目中将刚刚修改的submodule提交会稍微繁琐一些。在push之前，我们先看看project1-b的状态123456789101112131415C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib1 (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) lib1(new commits)表示lib1有新的提交，这个比较特殊。再看看project1-b主项目的变化123456789C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git diffdiff --git a/lib1 b/lib1index 1ffa3a9..f220249 160000--- a/lib1+++ b/lib1@@ -1 +1 @@-Subproject commit 1ffa3a92c147a2d09fadbc5129389cc6fd1b95cb+Subproject commit f220249eb39266a4fdc8e46a1164613a953ac3a4 从diff的结果可以看出，lib1的commit id从原来的1ffa3a92c147a2d09fadbc5129389cc6fd1b95cb更新为f220249eb39266a4fdc8e46a1164613a953ac3a4 注意： 这个时候，如果我们执行了git submodule update操作，那么lib1会还原到1ffa3a92c147a2d09fadbc5129389cc6fd1b95cb 这样的话，我们刚刚的修改是不是就丢失了呢？其实并不会，因为刚刚我们已经提交到了master分支，只需要再执行git checkout master就可以了 现在我们把lib1的修改提交到仓库1234567891011C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ cd lib1\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\lib1 (master -&gt; origin)λ git pushEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Writing objects: 100% (3/3), 291 bytes | 291.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/ dd43aec..f220249 master -&gt; master 千万不要以为到这里就结束了，后面还有很重要的一步,提交project1-b引用的submodule的commit id：123456789101112131415161718C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git add .C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git commit -m &quot;update lib1 to lastest commit id&quot;[master 3a6818e] update lib1 to lastest commit id 1 file changed, 1 insertion(+), 1 deletion(-)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git pushEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 253 bytes | 253.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git b0389b8..3a6818e master -&gt; master OK，现在大功告成，我们已经成功的在项目project1-b中修改了公共仓库lib1，并且把最新的lib1的commit id提交到了仓库。 接下来我们来看看project1怎么获取submodule。 1.5 更新主项目的submodule首先进入project1的目录1234567891011121314151617181920212223242526272829303132C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ cd ..\project1\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git pullremote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Compressing objects: 100% (2/2), done.remote: Total 2 (delta 1), reused 0 (delta 0)Unpacking objects: 100% (2/2), done.From C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git\ b0389b8..3a6818e master -&gt; origin/masterFetching submodule lib1From C:/Users/TAL-YINGYU/Desktop/repo/lib1 1ffa3a9..f220249 master -&gt; origin/masterUpdating b0389b8..3a6818eFast-forward lib1 | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib1 (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 可以看出，我运行了git pull和git status获取了远程仓库最新的源码，并且看到本地的状态为modified，这是为什么呢？我们来比较一下123456789C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git diffdiff --git a/lib1 b/lib1index f220249..1ffa3a9 160000--- a/lib1+++ b/lib1@@ -1 +1 @@-Subproject commit f220249eb39266a4fdc8e46a1164613a953ac3a4+Subproject commit 1ffa3a92c147a2d09fadbc5129389cc6fd1b95cb 从比较结果来看，是因为submodule的commit id更改了，我们前面提到，主项目更新submodule的内容时，首先要提交submodule的内容，然后再更新主项目中引用的submodule的commit id。现在我们看到的不同，就是因为刚才更改了project1-b的submodule commit id。ok，我们来更新一下project1的submodules：12345678910C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git submodule updateSubmodule path &apos;lib1&apos;: checked out &apos;f220249eb39266a4fdc8e46a1164613a953ac3a4&apos;C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.nothing to commit, working tree clean 1.6 为project2添加submodules lib1和lib2话不多说，直接上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cd ..\project2\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git submodule add C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/Cloning into &apos;C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project2/lib1&apos;...done.warning: LF will be replaced by CRLF in .gitmodules.The file will have its original line endings in your working directoryC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git submodule add C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/Cloning into &apos;C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project2/lib2&apos;...done.warning: LF will be replaced by CRLF in .gitmodules.The file will have its original line endings in your working directoryC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ lslib1/ lib2/ project2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git submodule initC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: .gitmodules new file: lib1 new file: lib2C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git commit -a -m &quot;add submodules(lib1 and lib2)&quot;[master 12516ae] add submodules(lib1 and lib2) 3 files changed, 8 insertions(+) create mode 100644 .gitmodules create mode 160000 lib1 create mode 160000 lib2C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git pushEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 12 threadsCompressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 440 bytes | 440.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project2.git\ fdefcbe..12516ae master -&gt; master 相信上面的代码都很熟悉了，就不过多展开了。 1.7 修改lib1和lib2并同步到project1和project2 我们假如，组员n同时负责peoject1和project2，有可能出现peoject1的某个时候发现lib1或者lib2有个bug，并且这个bug可能会影响很多需求模块，那么我们应该怎么办呢？ 现在假设需求如下： 在lib1中添加一个文件，README，用来描述lib 在lib2中的lib2-infos.md添加以下描述语句：“学习git submodule的修改，同步功能” 1.7.1 在lib1中添加一个文件1234567891011121314151617181920212223242526272829C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ cd lib1\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib1 (master -&gt; origin)λ echo &quot;lib1 README&quot; &gt; READMEC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib1 (master -&gt; origin)λ lslib1-infos.md READMEC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib1 (master -&gt; origin)λ git add READMEC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib1 (master -&gt; origin)λ git commit -m &quot;add file README&quot;[master 139f263] add file README 1 file changed, 1 insertion(+) create mode 100644 READMEC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib1 (master -&gt; origin)λ git pushEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 297 bytes | 297.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/ f220249..139f263 master -&gt; master 前面的文章提到，这个时候我们只完成了第一步，还有很重要的更新lib1的commit id 一步：12345678910111213141516171819202122232425262728293031323334C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib1 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib1 (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git add lib1C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git commit -m &quot;update lib1 to lastest commit id&quot;[master a29cc13] update lib1 to lastest commit id 1 file changed, 1 insertion(+), 1 deletion(-) C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git pushEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 251 bytes | 251.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project2.git\ 12516ae..a29cc13 master -&gt; master 1.7.2 在lib2的lib2-infos添加内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ cd lib2C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib2 (master -&gt; origin)λ echo &quot;学习git submodule的修改，同步功能&quot; &gt;&gt; lib2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib2 (master -&gt; origin)λ git add lib2-infos.mdC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib2 (master -&gt; origin)λ git commit -m &quot;add descript sentence&quot;[master 5d24031] add descript sentence 1 file changed, 1 insertion(+)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib2 (master -&gt; origin)λ git pushEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 307 bytes | 307.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/ 1f05672..5d24031 master -&gt; master C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2\lib2 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib2 (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git add lib2C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git commit -m &quot;update lib2 to lastest commit id&quot;[master 1f0f0f4] update lib2 to lastest commit id 1 file changed, 1 insertion(+), 1 deletion(-)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git pushEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 253 bytes | 253.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project2.git\ a29cc13..1f0f0f4 master -&gt; master 1.8 在project1中同步peoject2的lib1和lib2的修改现在project2里lib1和lib2的更改已经提交了，我们来更新project1的submodules（实际情况可能会有很多项目需要更新）：123456C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ cd ..\project1C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git pullAlready up to date. 什么情况？？？明明在project2中lib1和lib2已经更新了呀！为什么project1执行git pull得不到任何改动呢？ 我们来分析一下，首先来看下project1和project2的submodule状态：1234567891011#project1C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git submodule f220249eb39266a4fdc8e46a1164613a953ac3a4 lib1 (remotes/origin/HEAD) 1f05672f7ff92395fcbbe325ab2cda7405da40e8 lib2 (heads/master) #project2C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project2 (master -&gt; origin)λ git submodule 139f263f4c444d140d3ca3efe7d949f4b2a5b77b lib1 (heads/master) 5d2403124046f72b364b0355717013c8221d1fbd lib2 (heads/master) 区别： commit id 各不相同 lib1 所处的分支不相同 1.8.1 更新project1的lib1和lib2还记得刚才在project2中修改的时候，我们都是在master分支上操作的，那么目前project1中的lib1不在任何分支，所以我们先切换到master分支：123456789C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cd lib1C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1\lib1 (HEAD detached at f220249 -&gt; origin)λ git checkout masterPrevious HEAD position was f220249 modify lib1-infos.md by developer mSwitched to branch &apos;master&apos;Your branch is behind &apos;origin/master&apos; by 2 commits, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) 果然切换分支就发现了我们当前已经落后了两个commit( 我们刚刚在project2中push了 2 次 )了!那么还等什么？赶紧更新啊1234567891011121314151617181920212223242526272829303132333435363738394041C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1\lib1 (master -&gt; origin)λ git pullremote: Enumerating objects: 4, done.remote: Counting objects: 100% (4/4), done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From C:/Users/TAL-YINGYU/Desktop/repo/lib1 f220249..139f263 master -&gt; origin/masterUpdating 1ffa3a9..139f263Fast-forward README | 1 + lib1-infos.md | 2 +- 2 files changed, 2 insertions(+), 1 deletion(-) create mode 100644 READMEC:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1\lib1 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib1 (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git diffdiff --git a/lib1 b/lib1index f220249..139f263 160000--- a/lib1+++ b/lib1@@ -1 +1 @@-Subproject commit f220249eb39266a4fdc8e46a1164613a953ac3a4+Subproject commit 139f263f4c444d140d3ca3efe7d949f4b2a5b77b ok，可以看得出lib1的commit id已经随着pull的操作和project2目前的状态一致，说明已经同步到了。那么我们用同样的办法更新lib2吧：12345678910111213141516C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cd lib2\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1\lib2 (master -&gt; origin)λ git pullremote: Enumerating objects: 5, done.remote: Counting objects: 100% (5/5), done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From C:/Users/TAL-YINGYU/Desktop/repo/lib2 1f05672..5d24031 master -&gt; origin/masterUpdating 1f05672..5d24031Fast-forward lib2-infos.md | 1 + 1 file changed, 1 insertion(+) 1.8.2 更新project1中的submodule引用在1.7.1中，我们更新了project1中lib1和lib2的最新版本，现在要把最新的commit id 保存在project1中，以保持最新的引用1234567891011121314151617181920212223242526272829303132C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1\lib2 (master -&gt; origin)λ cd ..C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib1 (new commits) modified: lib2 (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git commit -a -m &quot;update lib1 and lib2 commit id to lastest version&quot;[master b5208b3] update lib 2 files changed, 2 insertions(+), 2 deletions(-)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ git pushEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 326 bytes | 326.00 KiB/s, done.Total 2 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git\ 3a6818e..b5208b3 master -&gt; master 1.9 使用脚本更新project1-b项目的submodules12345678910111213141516171819202122232425262728293031323334353637C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1 (master -&gt; origin)λ cd C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b\C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git pullremote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Compressing objects: 100% (2/2), done.remote: Total 2 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (2/2), done.From C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1 3a6818e..b5208b3 master -&gt; origin/masterFetching submodule lib1From C:/Users/TAL-YINGYU/Desktop/repo/lib1 f220249..139f263 master -&gt; origin/masterFetching submodule lib2From C:/Users/TAL-YINGYU/Desktop/repo/lib2 1f05672..5d24031 master -&gt; origin/masterUpdating 3a6818e..b5208b3Fast-forward lib1 | 2 +- lib2 | 2 +- 2 files changed, 2 insertions(+), 2 deletions(-)C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib1 (new commits) modified: lib2 (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 可以看到，git判断出lib1和lib2有更新，这就是根据submodule的commit id引用 1.9.1 思考那么现在我们怎么更新呢？难道还像刚才一样按照子模块一个一个的git checkout master，然后git pull？ 这里只有两个子模块，如果多了呢？ 实际上有一个更简便的命令可以替代上述操作：1git submodule foreach git pull 循环.gitsubmodules文件里子模块的路径，依次进行子模块更新 同理我们可以模仿上述命令123git submodule foreach ls -l``` 可以列出每个子模块的文件列表 git submodule foreach git checkout master12345每个子模块切换到master#### 1.9.2 实践先后执行下面两条语句即可 切换到master C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git submodule foreach git checkout masterEntering ‘lib1’Switched to branch ‘master’Your branch is behind ‘origin/master’ by 1 commit, and can be fast-forwarded. (use “git pull” to update your local branch)Entering ‘lib2’Switched to branch ‘master’Your branch is behind ‘origin/master’ by 1 commit, and can be fast-forwarded. (use “git pull” to update your local branch)1拉取 C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-b (master -&gt; origin)λ git submodule foreach git pullEntering ‘lib1’Updating f220249..139f263Fast-forward README | 1 + 1 file changed, 1 insertion(+) create mode 100644 READMEEntering ‘lib2’Updating 1f05672..5d24031Fast-forward lib2-infos.md | 1 + 1 file changed, 1 insertion(+)1### 1.10 新员工入职，克隆带有submodule的项目 git clone /path/to/repo/xxx.gitgit submodule initgit submodule update123这时候新员工心里肯定嘀咕：这是什么操作？？这么麻烦！！ 我们可以一行代码搞定 git clone –recursive /path/to/repo/xxx.git1234解释一下： `--recursive`:可以在clone项目的同时clone关联的submodules#### 1.10.1 一键clone project2 C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone –recursive ..\repo\project2.git\ prject2-auto-clone-submodulesCloning into ‘prject2-auto-clone-submodules’…done.Submodule ‘lib1’ (C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/) registered for path ‘lib1’Submodule ‘lib2’ (C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/) registered for path ‘lib2’Cloning into ‘C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/prject2-auto-clone-submodules/lib1’…done.Cloning into ‘C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/prject2-auto-clone-submodules/lib2’…done.Submodule path ‘lib1’: checked out ‘139f263f4c444d140d3ca3efe7d949f4b2a5b77b’Submodule path ‘lib2’: checked out ‘5d2403124046f72b364b0355717013c8221d1fbd’ C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ lslib1/ lib2/ prject2-auto-clone-submodules/ project1/ project1-b/ project2/ C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ ls prject2-auto-clone-submodules\lib1/ lib2/ project2-infos.md1234是不是爽歪歪~~~## 2. 移除submodule重新clone一个项目来练习移除submodule C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ git clone –recursive ..\repo\project1.git\ project1-remove-submodulesCloning into ‘project1-remove-submodules’…done.Submodule ‘lib1’ (C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/) registered for path ‘lib1’Submodule ‘lib2’ (C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/) registered for path ‘lib2’Cloning into ‘C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project1-remove-submodules/lib1’…done.Cloning into ‘C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/project1-remove-submodules/lib2’…done.Submodule path ‘lib1’: checked out ‘139f263f4c444d140d3ca3efe7d949f4b2a5b77b’Submodule path ‘lib2’: checked out ‘5d2403124046f72b364b0355717013c8221d1fbd’ C:\Users\TAL-YINGYU\Desktop\workSpaceLocalλ cd project1-remove-submodules\1### 2.1 删除git cache C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ git rm -f –cached lib1rm ‘lib1’ C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ git rm -f –cached lib2rm ‘lib2’1### 2.2 物理删除本地文件夹和.gitmodules C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ rm -f lib1rm: cannot remove ‘lib1’: Is a directory C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ rm -rf lib1 C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ rm -rf lib2 C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ lsproject1-infos.md C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ rm -rf .gitmodules 1234因为这里只有两个子模块，所以直接删除了`.gitmodules`,如果只需要删除某一个子模块，则在文件中删除对应的配置即可。### 2.3 删除`.git/config`的submodule配置源文件： C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ cat .git\config[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[submodule] active = .[remote “origin”] url = C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git\ fetch = +refs/heads/:refs/remotes/origin/[branch “master”] remote = origin merge = refs/heads/master[submodule “lib1”] url = C:/Users/TAL-YINGYU/Desktop/repo/lib1.git/[submodule “lib2”] url = C:/Users/TAL-YINGYU/Desktop/repo/lib2.git/1删除后： C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ cat .git\config[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote “origin”] url = C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git\ fetch = +refs/heads/:refs/remotes/origin/[branch “master”] remote = origin merge = refs/heads/master1### 2.4 提交更改 C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with ‘origin/master’. Changes to be committed: (use “git reset HEAD …” to unstage) deleted: lib1 deleted: lib2 Changes not staged for commit: (use “git add/rm …” to update what will be committed) (use “git checkout – …” to discard changes in working directory) deleted: .gitmodules C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ git add .gitmodules C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ git statusOn branch masterYour branch is up to date with ‘origin/master’. Changes to be committed: (use “git reset HEAD …” to unstage) deleted: .gitmodules deleted: lib1 deleted: lib2 C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ git commit -m “delete submodules”[master b26add0] delete submodules 3 files changed, 8 deletions(-) delete mode 100644 .gitmodules delete mode 160000 lib1 delete mode 160000 lib2 C:\Users\TAL-YINGYU\Desktop\workSpaceLocal\project1-remove-submodules (master -&gt; origin)λ git pushEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 12 threadsCompressing objects: 100% (1/1), done.Writing objects: 100% (2/2), 243 bytes | 243.00 KiB/s, done.Total 2 (delta 0), reused 0 (delta 0)To C:/Users/TAL-YINGYU/Desktop/workSpaceLocal/..\repo\project1.git\ b5208b3..b26add0 master -&gt; master123456789## 3. END零零碎碎总算写完了，写的有点啰嗦。 不过实际上，确实需要经过自己练习，才能熟练掌握git submodule的使用技巧。 如果你有更好的方法，希望能留下宝贵的意见。## 4. `git submodule foreach xxx`可真是个万金油拉取所有子模块 git submodule foreach git pullgit submodule foreach –recursive git submodule initgit submodule foreach –recursive git submodule update```]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-初级算法-存在重复元素]]></title>
    <url>%2F2018%2F09%2F13%2FLeetcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 题目 给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例1输入: [1,2,3,1]输出: true示例 2:输入: [1,2,3,4]输出: false示例 3:输入: [1,1,1,3,3,4,3,2,4,2]输出: true 自己的思路思路1 双层循环，就是想着说先用最笨的办法实现了，后面在优化 耗时：1764ms 12345678910111213class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for (int i = 0; i &lt; size; i++) &#123; for (int j = i + 1; j &lt; size; j++)&#123; if (nums[i] == nums[j]) return true; &#125; &#125; return false; &#125;&#125;; 思路2 采用双指针循环法基准指针先指向数组的第0个位置，游标指针指向数组的第1个位置，比较数据是否相等若想等，则返回true若不等，则游标指针所指向的数据复制到基准指针的下一位，基准指针和游标指针各自从当前位置向后移一位，再次比较 耗时：24ms 123456789101112131415161718192021222324class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if (1 == size) &#123; return false; &#125; sort(nums.begin(), nums.end()); int start = 0; int next = 1; while (next &lt; size) &#123; if (nums[start] == nums[next]) &#123; return true; &#125; else &#123; nums[start +1] = nums[next]; ++start; ++next; &#125; &#125; return false; &#125;&#125;; 网上优秀思路 在数组不为空且数组元素个数大于2的情况下，对数组元素循环对比，同时，用一个临时变量来保存从0到i-1之间的最大元素，如果当前值比之前的值都大，那么这之前的值里面不可能有比它再大的值，从而就减少了查询次数 耗时：8ms 以下第一段代码解释参见我的博客C++中优化IO效率 – 点击直达 123456789101112131415161718192021222324252627282930313233343536373839static const auto xxx = []() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr;&#125;();class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty() || 1 == nums.size()) &#123; return false; &#125; int temp = nums[0]; for(int i = 1; i &lt; nums.size(); ++i) &#123; if(temp &lt; nums[i]) &#123; temp = nums[i]; &#125; else if(temp == nums[i]) &#123; return true; &#125; else &#123; for(int j = 0; j &lt; i; ++j) &#123; if(nums[i] == nums[j]) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-初级算法-数组循环右移]]></title>
    <url>%2F2018%2F09%2F13%2FLeetcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例1输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]示例2输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]说明 尽可能想出更多解决方案，至少有三种不同的方法可以解决这个问题 要求使用空间复杂度为O(1)的原地算法 自己的思路 在数组元素个数 n 不为0的前提下，分3种情况1.如果 k 和 n 相同，则数组不变2.如果 k 小于 n ，则对数组进行 k 次循环，把最后一个元素移到第一个元素，其他依次后移3.如果 k 大于 n ，则对数组进行 k-n 次循环，重复步骤2 耗时: 384ms 这个思路大概是最笨的方法，不得不承认，自己对于算法还是弱鸡。 123456789101112131415161718192021222324class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) return; if (nums.size() &gt; k)&#123; for (int j = 0; j &lt; k; j++)&#123; int temp = nums[nums.size() - 1]; for (int i = nums.size() - 1; i &gt; 0; i--)&#123; nums[i] = nums[i - 1]; &#125; nums[0] = temp; &#125; &#125; else if (nums.size() &lt; k)&#123; rotate(nums, k-nums.size()); &#125; for (int i = 0; i &lt; nums.size(); i++)&#123; cout &lt;&lt; nums[i]; &#125; &#125;&#125;; 网上的优秀思路 这个思路是使用了C++标准库函数 reverse假设输入数组的下标是0 ~ n-1，需要旋转的步数是k，那么按照下面的方法就可以完成旋转数组（其中reverse表示用双指针交换的方法翻转数组）：step 1. reverse原来的数组。step 2. reverse 0~ k-1。step 3. reverse k ~ n-1。那么得到的新数组就是个旋转数组了。 举个例子来说是这样的：元素组： 1 2 3 4 5 翻转步长：k=3step 1 reverse原来的数组： 5 4 3 2 1step 2 reverse 0~ k-1： 3 4 5 2 1step 3 reverse k ~ n-1: 3 4 5 1 2最后的【3 4 5 1 2】就是旋转数组的结果了，这种方法的时间复杂度是o（n），空间复杂度是o（1），是非常好的方法了耗时: 12ms 123456789class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k = k % nums.size(); reverse(nums.begin(), nums.begin() + nums.size() - k); reverse(nums.begin() + nums.size() - k, nums.end()); reverse(nums.begin(), nums.end()); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中优化IO效率]]></title>
    <url>%2F2018%2F09%2F13%2FC%2B%2B%E4%B8%AD%E4%BC%98%E5%8C%96IO%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 前言最近在刷LeetCode的时候，发现时间靠前的答案总是会有以下类似代码12345static const auto xxx = []() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr;&#125;(); 看到这个第一反应是懵逼的，仔细分析了一下，是一个lambda表达式，但是表达式的内容就看的晕晕乎乎了。 正文参考了网友的部分解答，对上述代码的解答基本如下：这两段代码的都文件都是 iostream std::ios::sync_with_stdio() Sets whether the standard C++ streams are synchronized to the standard C streams after each input/output operation.设置在每次输入/输出操作后标准C ++流是否与标准C流同步 另有std::cin的解释如下 The global objects std::cin and std::wcin control input from a stream buffer of implementation-defined type (derived from std::streambuf), associated with the standard C input stream stdin. These objects are guaranteed to be constructed before the first constructor of a static object is called and they are guaranteed to outlive the last destructor of a static object, so that it is always possible to read from std::cin in user code. Unless sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input. Once std::cin is constructed, std::cin.tie() returns &amp;std::cout, and likewise, std::wcin.tie() returns &amp;std::wcout. This means that any formatted input operation on std::cin forces a call to std::cout.flush() if any characters are pending for output. 基本可以了解到，C++为了兼容C语言，保证在代码中同时出现std::cout/std::cin和printf/scanf方法时不发生混乱，所以C++使用了一个缓冲区来同步C的标准IO流，通过使用std::ios::sync_with_stdio(false)来解除这种同步，是cout和cin不再经过缓冲区，进而节省了部分时间。但是要注意：解除了同步之后，不能再使用C的库函数（scanf,getchar,gets,fgets,fscanf之类） std::cin.tie Get/set tied streamThe first form (1) returns a pointer to the tied output stream. The second form (2) ties the object to tiestr and returns a pointer to the stream tied before the call, if any. The tied stream is an output stream object which is flushed before each i/o operation in this stream object. C++11By default, the standard narrow streams cin and cerr are tied to cout, and their wide character counterparts (wcin and wcerr) to wcout. Library implementations may also tie clog and wclog. 这个理解起来又容易一些，因为std :: cin默认是与std :: cout绑定的，所以每次操作的时候（也就是调用”&lt;&lt;”或者”&gt;&gt;”）都要刷新（调用flush），这样增加了IO的负担，通过tie(nullptr)来解除std :: cin和std :: cout之间的绑定，来降低IO的负担使效率提升。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中getchar、scanf等输入]]></title>
    <url>%2F2018%2F08%2F30%2FC-%E4%B8%ADgetchar%E3%80%81scanf%E7%AD%89%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[基本定义getchar123456789101112int getchar(void)&#123; static char buf[BUFSIZ]; static char* bb=buf; static int n=0; if(n==0) &#123; n=read(0,buf,BUFSIZ); bb=buf; &#125; return(--n&gt;=0)?(unsigned char)*bb++:EOF;&#125; 该函数声明在 中。Reads a character from standard input. 当程序调用getchar时，程序就等着用户按键输入，以回车结束输入。 用户输入的字符存放在键盘缓冲区中（回车也存放在缓冲区中）。 当用户按下回车之后，getchar开始从缓冲区每次读取一个字符。getchar函数返回值是用户输入字符的ASCII码值，若EOF(End-Of-File)则返回-1，并且将用户输入的字符回显到屏幕。 也就是说：如果缓冲区有数据的话，getchar()方法不用等你手动输入，它会直接读取一个字符。 getchgetch功能基本上与getchar相同。区别在于getch不等待回车，只要用户按一个键，就会立刻返回。getch返回值也是ASCII码值，出错返回-1。注意：getch函数是非缓冲输入函数，即不能用getch来接收缓冲区已存在的字符。 通常getch用于程序调试中，在关键位置显示有关结果以查看，然后用getch函数暂停程序运行，按下任一按键继续程序运行。 getche与上面两个函数功能类似，都是接收一个字符，返回值同样是ASCII码值。 不同的是，此函数在输入后立刻从控制台读取字符，不以回车为结束标识。 scanfscanf这个函数比较特别scanf输入字符串，整型，实型等数据的判断方式都一样，回车，空格，tab键都会被认为是输入的结束。当然字符的话，一个字符就是结束了。 回车、空格等都有对应的ASCII码，所以用scanf输入字符时要小心这些东西被当成字符输进去，而输入字符串和整型、实型等数据时这些都被当成分隔符而不会被输入到字符数组或变量里。 如果scanf输入的不是字符，那么分隔符为回车，空格、tab键时，两个数据之间的分隔符只是起区别两个数据的作用，把分隔好的两个数据分别赋值到各自定义好的变量或数组中去，两个数据之间的分隔符被从缓冲区读出但是不起任何作用，当然最后一个’\n ‘会被留在缓冲区内，除非用getchar();或scanf(“%c”,&amp;c);把它读出来。回车是一定要有的，不管getchar还是scanf只要是通过缓冲区输入数据的函数都是等待回车键 ‘\n ‘出现才进入缓冲区的。 程序举例12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main(int argc)&#123; int a, c; printf(&quot;please input a char: \n&quot;); a = getchar(); if (EOF != a) &#123; printf(&quot;aaa == %c \n&quot;, a); &#125; while ((c = getchar()) != &apos;\n&apos; ) &#123; if (EOF == a) &#123; break; &#125; printf(&quot;ccc == %d \n&quot;, c); &#125; printf(&quot;press any key to continue: \n&quot;); getchar(); //此处 getchar()在这里作用等同于 system(&quot;pause&quot;);&#125; 结果为]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-初级算法-两数之和]]></title>
    <url>%2F2018%2F08%2F30%2FLeetcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 自己的思路 遍历每个元素 x，并查找是否存在一个值与 target−x 相等的目标元素。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; vecResult; for (int i = 0; i &lt; nums.size(); i++) &#123; for(int j = i + 1; j &lt; nums.size(); j++) &#123; if(nums[i] == target - nums[j]) &#123; vecResult.push_back(i); vecResult.push_back(j); &#125; &#125; &#125; return vecResult; &#125;&#125;; 复杂度分析： 时间复杂度：O(n2) 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n2)。 空间复杂度：O(1) 网上优秀思路 通过牺牲空间换取速度的方式。将vector的元素添加到map的键值对中，同时检查表中是否已经存在当前元素所对应的目标元素。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; vecResult; map&lt;int, int&gt; mapResult; for (int i = 0; i &lt; nums.size(); i++) &#123; int complement = target - nums[i]; auto it = mapResult.find(complement); if (it != mapResult.end()) &#123; vecResult.push_back(i); vecResult.push_back(it-&gt;second); &#125; mapResult[nums[i]] = i; &#125; return vecResult;&#125; 复杂度分析： 时间复杂度：O(n) 我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。 空间复杂度：O(n) 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。 貌似使用hash_map效率会更高]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面试]]></title>
    <url>%2F2018%2F08%2F27%2FC-%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[记录自己遇到的一些C++基础面试题目 基础部分 override和final的区别 override是用来标识派生类需要重写的方法;final是用来标识派生类不能重写的方法 sizeof的用法首先应该明确sizeof是一个C语言关键字而不是一个函数，用于计算数据空间的字节数，其计算发生在编译时刻。 sizeof运算符的结果部分依赖于其作用的类型： 对char或者类型为char的表达式执行sizeof运算，结果为1 对引用执行sizeof运算结果得到被引用对象本身所占空间的大小 对指针执行sizeof运算得到指针本身所占空间的大小 对解引用指针执行sizeof运算得到指针所指向的对象所占空间大小，指针不需要有效 对数组执行sizeof运算得到整个数组所占空间大小，等价于对数组中所有元素各执行一次sizeof运算并求和。注意：sizeof运算不会把数组转化成指针来处理 对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间 类型 大小 int *p sizeof(p) = 4；//sizeof(*p) 相当于sizeof(int) int a[10] sizeof(a) = 4*10 char a = “hello” sizeof(a) = 6; //结尾处有\0 double (a)[3][6]; sizeof(a) = 4; //a为指针 sizeof(a) = 72; // \a为有3*6个元素的数组 sizeof(*a) = 24; // \*a为数组一维的6个指针 sizeof(**a) = 4; // \**a为数组一维的第一个指针 sizeof(**a) = 8; // ****a为double类型的变量 算法]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中int与bye的相互转换]]></title>
    <url>%2F2018%2F07%2F21%2FC-%E4%B8%ADint%E4%B8%8Ebye%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 byte不是一种新类型，在C++中byte被定义的是unsigned char类型；但在C#里面byte被定义的是unsigned int类型 int转byte 12345678910 void intToByte(int i,byte *bytes,int size = 4) &#123; //byte[] bytes = new byte[4]; memset(bytes,0,sizeof(byte) * size); bytes[0] = (byte) (0xff &amp; i); bytes[1] = (byte) ((0xff00 &amp; i) &gt;&gt; 8); bytes[2] = (byte) ((0xff0000 &amp; i) &gt;&gt; 16); bytes[3] = (byte) ((0xff000000 &amp; i) &gt;&gt; 24); return ; &#125; byte转int1234567int bytesToInt(byte* bytes,int size = 4) &#123; int addr = bytes[0] &amp; 0xFF; addr |= ((bytes[1] &lt;&lt; 8) &amp; 0xFF00); addr |= ((bytes[2] &lt;&lt; 16) &amp; 0xFF0000); addr |= ((bytes[3] &lt;&lt; 24) &amp; 0xFF000000); return addr; &#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C++中memset方法的使用笔记]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%85%B3%E4%BA%8EC-%E4%B8%ADmemset%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文首发于我的个人Blog阿西BUG，欢迎大家批评指正 最近在用C++写服务端逻辑，在使用memset的时候出现了一些问题 现象memset在对一个二维数组进行初始化的时候，因为某些原因需要初始化不为0，这就导致了问题的出现 先贴代码看12WORD wLeftCardData[2][30];memset(m_pLeftCardInfo-&gt;wLeftCardData[1], 4, sizeof(WORD)* 30); 得到的结果不是我想要的4， 而是1028 真是百思不得其解。。。。 memset原理memset方法原型是: void *memset( void *buffer, int ch, size_t count );功能：函数拷贝ch 到buffer 从头开始的count 个字符里, 并返回buffer指针。 memset() 可以应用在将一段内存初始化为某个值。例如： memset( the_array, &#39;\0&#39;, sizeof(the_array) ); 这是将一个数组的所有分量设置成零的很便捷的方法。 错误分析memset方法是按照字节进行赋值的在我的错误代码中，WORD类型占两个字节，那么memset就会分别对WORD的高字节和低字节分别填充4这个值,那么每个WORD的值就相当于0x4040 = 1028 总结 memset函数按字节对内存块进行初始化 所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同） memset(void *s, int ch,size_tn); 中ch实际范围应该在0~~255，因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节 比如int a[5]赋值memset（a,-1,sizeof(int )5）与memset（a,511,sizeof(int )5） 所赋值的结果是一样的都为-1； 因为-1的二进制码为（11111111 11111111 11111111 11111111），而511的二进制码为（00000000 00000000 00000001 11111111）后八位都为（11111111) 替代方案那么，有没有什么好的方法替代memset对变量进行非0/1的初始化呢？答案是有的可以参考std::fill方法]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始搭建ss多用户控流vps]]></title>
    <url>%2F2017%2F12%2F19%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAss%E5%A4%9A%E7%94%A8%E6%88%B7%E6%8E%A7%E6%B5%81vps%2F</url>
    <content type="text"><![CDATA[我想这大概是对新手最完整的教程了….闲话不多说，开始正题 基础环境配置这里我们使用的服务器为CentOS v7版本,相关配置为Nginx v1.12 + MySQL v5.7 + PHP v7.0.5 .其他版本大同小异，各自注意区分即可。这里的服务器是全新的服务器，上面什么配置都没有的。所以首先我们安装一些必备的工具。依次执行如下命令，安装wget下载工具：yum install wget安装gcc编译工具：yum install gcc安装git服务：yum install git安装python pip：yum install python-pip Nginx安装配置这里使用CentOS自带的yum命令安装：首先，执行rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm ,可以通过变换上面的地址找到和自己服务器对应版本的 repo 的 rpm。安装好 yum repo 之后，接下来用 yum 安装 nginxyum install nginx到此Nginx已经安装完成，可以执行 nginx -v 查看版本设置开机启动：systemctl enable nginx立即启动NginxSystemctl start nginx查看Nginx服务状态Systemctl status nginx到此，Nginx已经安装配置完成，可以在浏览器输入服务器ip访问，看到Nginx欢迎页面即为成功。 MySQL安装配置这里同样用 yum 安装 MySQL.rpm -Uvh http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm接着安装 MySQLyum install mysql-community-server mysql-community-devel安装完成的默认配置文件会在这个路径 /etc/my.cnf 可以根据实际需要修改里边的选项。这里要注意的配置文件中如下位置，因为后面配置 PHP 的时候讲会用到：socket=/var/lib/mysql/mysql.sock看看下 MySQL 的状态systemctl status mysqld结果如下表示安装完成并且已经添加到了自启动：1234mysqld.service - MySQL ServerLoaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled)Active: inactive (dead)... 启动MySQL：systemctl start mysqldMySQL v5.7版本是会自动为 root@localhost用户创建一个默认密码的，可以通过如下命令找到：1grep `temporary password` /var/log/mysqld.log 2016-04-07T15:39:59.942230Z 1 [Note] A temporary password is generated for root@localhost: UH!e%iTsIgs: 上面的 UH!e%iTsIgs 就是默认密码，现在可以登入MySQL并修改密码：mysql -uroot -p Enter password:Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.11… MySQL 5.7 版本对密码的安全性要求很严格，必须至少包含1个大写字母、1个小写字母、1个数字和1个特殊字符，长度不得小于8个字符。修改密码：1mysql&gt; ALTER USER `root`@`localhost` IDENTIFIED BY `Lnmp.cn8`; 其中Lnmp.cn8 就是新密码。退出MySQL：mysql&gt; quit PHP v7安装配置下载源码到 usr/local/src，cd usr/local/srcwget -c http://cn2.php.net/distributions/php-7.0.5.tar.gz解压tar -zxvf php-7.0.5.tar.gz进入解压后的文件夹：cd php-7.0.5/可以通过./configure --help看到，有三百多个扩展选项，可以自己根据需要增减，这里我们预先那些准备装的扩展要用到的软件模块yum -y install libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-devel接下来configure PHP./configure --prefix=/usr/local/php7 --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-pdo-mysql --with-mysql-sock=/var/lib/mysql/mysql.sock --with-zlib --with-curl --with-gd --with-jpeg-dir --with-png-dir --with-freetype-dir --with-openssl --enable-mbstring --enable-xml --enable-session --enable-ftp --enable-pdo -enable-tokenizer --enable-zip 值得一提的是，PHP7已经删除了MySQL扩展，所以 -with-mysql 不再是一个有效的选项。这里用 PDO 代替。其中 –prefix 是安装目录，如果需要在同一个服务器安装多个 PHP 版本，这个 –prefix 设定是很有必要的。configure成功会有 Thank you for using PHP 字样。编译：make然后make install如果安装 PHP 时没有指明 –prefix ，那么就 php.ini 路径就是 /usr/local/lib/php.ini 。刚才安装时有指明 –prefix ，所以是 /usr/local/php7/lib/php.ini然后根据实际自己需要修改 php.ini。vi /usr/local/php7/lib/php.ini查找 mysqli.default_socket，修改成：mysqli.default_socket = /var/lib/mysql/mysql.sock其中 /var/lib/mysql/mysql.sock 就是上面安装 MySQL 时提到的。这个值必须填，否则会出现如下错误：Warning: mysqli_connect(): (HY000/2002): No such file or directory修改时区，查找 date.timezone，改成：date.timezone = PRC好了，PHP 7 已经安装好，下面验证一下: /usr/local/php7/bin/php -v显示PHP版本即为成功。例行拷贝配置文件，以备不时只需cp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.confcp /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.conf可以打开/usr/local/php7/etc/php-fpm.d/www.conf看到如下字段12user = nginxgroup = nginx 1listen = 127.0.0.1:9000 如果文件中上述字段配置不一样，改为上述内容。其中listen = 127.0.0.1:9000要注意，9000这个端口在配置网站时要用到。配置 php-fpm 启动服务脚本：在解压后的php文件目录下执行：cp sapi/fpm/php-fpm.service /usr/lib/systemd/system/修改启动脚本，把里边 prefix 相关的内容用实际路径代替:vi /usr/lib/systemd/system/php-fpm.service将12PIDFile=$&#123;prefix&#125;/var/run/php-fpm.pidExecStart=$&#123;exec_prefix&#125;/sbin/php-fpm --nodaemonize --fpm-config $&#123;prefix&#125;/etc/php-fpm.conf 修改成12PIDFile=/usr/local/php7/var/run/php-fpm.pidExecStart=/usr/local/php7/sbin/php-fpm --nodaemonize --fpm-config /usr/local/php7/etc/php-fpm.conf 重新载入 systemdsystemctl daemon-reload让 php-fpm 随机启动systemctl enable php-fpm立即启动 php-fpmsystemctl start php-fpm查看状态：systemctl status php-fpm，看到服务running即可。 配置 Nginx 站点先建立一个 lnmp 站点，路径是 /www/lnmp/webmkdir -p /www/lnmp/web并准备好 phpinfo 测试文件vi /www/lnmp/web/phpinfo.php输入如下内容保存：123&lt;?phpphpinfo();?&gt; 每个站点建一个 Nginx 配置文件放到 /etc/nginx/conf.d/ 中cd /etc/nginx/conf.d/vi lnmp.cn.conf在 lnmp.cn.conf 中加入以下内容然后保存1234567891011121314server &#123; listen 80; server_name www.lnmp.cn; root /www/lnmp/web; location / &#123; index index.php index.html index.htm; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 其中 server_name www.lnmp.cn; 中的 www.lnmp.cn 改成你自己的域名其中 root /www/lnmp/web; 就是刚才创建的站点目录其中 fastcgi_pass 127.0.0.1:9000; 就是上面配置 php-fpm 提到要留意的值修改配置后一定要记得 reload nginx 才能生效systemctl reload nginx好了，大功告成，就打开刚才的域名验证下（如果没有已经指向配置好的服务器 IP的域名，使用ip也可以）如果打不开，或者报错dial tcp4 xxxxxx:80: getsockopt: no route to host那么说明你的服务器80端口还没打开，你需要1234firewall-cmd --zone=public --add-port=80/tcp --permanentsystemctl stop firewalld.servicesystemctl start firewalld.servicesystemctl status firewalld.service 安装并配置 ss-panel环境要求为前端的 ss-panel 是使用 PHP 编写的网页应用程序，它对你的主机运行环境有一定的要求。 PHP 5.6 或更高 MySQL 5.5 或更高 支持 URL 重写的 Web 服务器（Nginx / Apache 均可） 下载 ss-panel 源码ss-panel 的 GitHub 项目地址：orvice/ss-panelcd到你的web根目录下，clone ss-panel：git clone https://github.com/orvice/ss-panel.git -b v3其中 -b v3是代表clone v3版本的ss-panel当然你也可以下载源码再用 SCP/FPS 传到服务器上去。注意源码下载完成后的目录结构，请务必保证 /public 目录在站点的根目录下。你可以使用 mv ss-panel/{.,}* ./ 命令将子目录的内容移动到当前目录来。 配置 ss-panel这个时候访问你的站点是会得到403 Forbidden, 因为此时站点根目录下是没有index.php文件的。当然这样也很正常，大部分 MVC 框架都将 index.php 的入口文件放到其他子目录下了，这样做是为了保护根目录下的配置文件等可能会导致信息泄露的敏感文件无法被访问。接下来可以按照官方文档来配置的你web Step 112$ curl -sS https://getcomposer.org/installer | php$ php composer.phar install Step 2将 .env.example 复制一份重命名为 .env，自行修改其中的数据库等信息。cp .env.example .envthen edit .envvi .env你还需要修改 .env 中的 muKey 字段，修改为任意字符串（最好只包含 ASCII 字符），下面配置后端的时候我们需要使用到这个 muKey：muKey = &#39;api_key_just_for_test&#39;thenchmod -R 777 storage Step 3Import the sql to you mysql database.mysql -u root -p xxxxx &lt; db.sql,其中xxxxx是你的数据库名字 Step 4Nginx Config example:if you download ss-panel on path /home/www/ss-panel 1234root /home/www/ss-panel/public;location / &#123; try_files $uri $uri/ /index.php$is_args$args;&#125; 现在访问你的站点，不出意外，就可以看到ss-panel首页了。 进入 ss-panel 后台现在访问 http://your-domain/admin 就可以进入 ss-panel 后台了。不过细心的你可能会注意到，刚才导入数据表的时候，user 表并没有添加记录，那要咋进管理后台呢？当然你可以在数据库中手动加一条记录，不过作者已经提供了一个更方便的方式：php xcat createAdmin在站点根目录下运行，根据提示即可创建管理员账号。探后根据提示输入账号密码就可以登入到自己的后台了。 部署并配置 shadowsocks-manyuser安装 shadowsocks-manyuser我们使用 fsgmhoward/shadowsocks-py-mu 这个版本的后端。这个后端支持使用 MultiUser API 与前端的 ss-panel 进行用户信息交互。 这个 API 的官方介绍在这里。简单来讲，如果你通过 API 来与前端通信，你就不需要修改后端的数据库配置了，并且可以使用「自定义加密」、「流量记录」等高级功能。下面我只介绍使用 API 的方法。 先将代码 clone 到本地：git clone https://github.com/fsgmhoward/shadowsocks-py-mu.git其中的 shadowsocks 子目录才是我们需要的，外面的是 setup.py 的相关文件。 配置 shadowsocks-manyuser进入 shadowsocks 目录，将 config_example.py 复制一份到 config.py：cp config_example.py config.py修改其中的部分字段如下：12345API_ENABLED = TrueAPI_URL = &apos;http://xxxxxxx/mu&apos;# 就是上面在 .env 中填写的 muKey 把它填在这里API_PASS = &apos;api_key_just_for_test&apos; 此时我们就可以试着运行脚本了 python servers.py，这里要注意是 servers.py，而不是server.py如果没错的话，你大概会看到如下输出：1234567Dec 03 13:41:18 INFO -----------------------------------------Dec 03 13:41:18 INFO Multi-User Shadowsocks Server Starting...Dec 03 13:41:18 INFO Current Server Version: 3.4.0-devDec 03 13:41:18 INFO Now using MultiUser API as the user interfaceDec 03 13:41:18 INFO Now starting manager thread...Dec 03 13:41:23 INFO Now starting user pulling thread...Dec 03 13:41:23 INFO Server Added: P[1025], M[aes-256-cfb], E[xxxxxxxx.com] 其中 P[XXX] 表示用户端口，M[XXX] 表示加密方式，E[XXX] 表示用户的邮箱地址。这些都会随着 ss-panel 前端中用户配置的改变而实时变化。 此时你虽然已经把 servers.py 跑起来了，但是你应该还不能翻墙，因为还没有打开端口，所以此时你需要打开刚才输出中的端口，ss-panel 新注册的用户所分配的端口均为其 id-1 的用户的端口号 + 1。比如说你把 admin 用户（uid 为1）的端口改为 12450，那么后面注册的新用户的端口就会是 12451, 12452 这样递增的。所以此时你可以批量打开部分端口：1234firewall-cmd --permanent --zone=public --add-port=xxxx-xxxx/tcpsystemctl stop firewalld.servicesystemctl start firewalld.servicesystemctl status firewalld.service 到此，应该可以正常科学上网了。 配置 ss-manyuser 守护进程这里守护进程是希望servers.py在后台隐式运行，你可以：pip install supervisor创建 supervisor 配置文件:echo_supervisord_conf &gt; /etc/supervisord.conf配置 supervisor 以监控 ss-manyuser 运行/etc/supervisord.conf在文件尾部添加如下内容并修改为自己的实际路径：12345[program:ss-manyuser]command = python /usr/local/src/shadowsocks-py-mu/shadowsocks/servers.pyuser = rootautostart = trueautorestart = true 重启 supervisor 服务以加载配置supervisorctl reload查看 shadowsocks-manyuser 是否已经运行：ps -ef | grep servers.py1root 10288 2781 0 13:41 ? 00:00:00 python /usr/local/src/shadowsocks-py-mu/shadowsocks/servers.py 也可以通过以下命令管理 shadowsock-manyuser 的状态supervisorctl {start|stop|restart} ss-manyuser 至此，已经完成了多用户控流科学上网的配置了，叫上你的小伙伴一起享受冲浪的乐趣吧！ 常见错误 FAQ1 . 查看Nginx服务状态显示 Failed to read PID from file /run/nginx.pid: Invalid argument因为 nginx 启动需要一点点时间，而 systemd 在 nginx 完成启动前就去读取 pid file造成读取 pid 失败解决方法很简单，让 systemd 在执行 ExecStart 的指令后等待一点点时间即可如果你的 nginx 启动需要时间更长，可以把 sleep 时间改长一点mkdir -p /etc/systemd/system/nginx.service.dprintf &quot;[Service]\nExecStartPost=/bin/sleep 0.1\n&quot; &gt; /etc/systemd/system/nginx.service.d/override.conf然后systemctl daemon-reloadsystemctl restart nginx.service 2 . php: command not found原因是你的php并没有配置全局路径，加上绝对路径即可，例如/usr/local/php7/bin/php 3 . 配置ss-panel前端的时候站点提示：502 Bad Gateway因为 nginx 找不到php-fpm了，所以报错，一般是fastcgi_pass后面的路径配置错误了，后面可以是socket或者是ip:port例如：修改php-fpm的配置文件 vi /usr/local/php7/etc/php-fpm.conf 里面的 listen = /tmp/php-fcgi.sock 改为 listen = 127.0.0.1:9000 4 . 站点页面空白，没有任何提示检查你的nginx配置，我的如下： 1234567891011121314151617server &#123; listen 80; server_name xx.xx.xxx.xxx; #这里隐藏了我的IP index index.php index.html index.htm; root /www/ssmu/public; location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ [^/]\.php(/|$) &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 5 . 创建管理员账号时：Uncaught PDOException: could not find driver in …原因是缺少php pdo_mysql扩展 安装即可 6 . Slim Application Error一般是缺少权限，相应的文件夹赋予权限即可]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]关于手游网络协议的简单分析]]></title>
    <url>%2F2017%2F11%2F23%2F%E8%AF%91-%E5%85%B3%E4%BA%8E%E6%89%8B%E6%B8%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言大多数加密方案都假定可信的发送者和接收者会通过一个不可信的通道通信. 虽然假设发送者会故意尝试愚弄接收者有点荒谬,但这确实是摆在开发者面前的问题。有些玩家是不可信的, 更糟的是, 他们能够通过客户端执行文件获取对加密算法和所有通信的了解。在这样的情况下，我们不可能提供完全安全的通信，但是我们可以为攻击者制造麻烦。本文着重介绍一些实用的技术来为网络游戏建立一个应用程序级通讯协议。 Definitions 协议设计在基于客户端/服务器的游戏中是最有趣的，这种游戏由若干不可信的客户端和一个可信的中央服务器通信。(Cheating在点对点的游戏中当然也是个问题，不过因为这样的游戏中没有节点是可信的，所以这种情况是没希望的)在客户端/服务器游戏中cheat的后果是非常严重的，因为服务器作为唯一的可信实体，维护游戏状态并且验证所有客户端命令。当游戏状态稳定后, 一次成功的cheat能够使包括上千个玩家的游戏变得不稳定。 考虑在客户端/服务器系统中的协议安全性。客户端和服务器在网络通道中发送封包通信，网络通道或许可信(TCP),或许不可信(UDP).尽管客户端之间也能够直接通信，比如文字聊天或者声音，我们假定任何需要安全保证的数据只在客户端和服务器之间发送。 封包篡改(Packet Tampering) 大多数协议hackers是偶然的：他们改变封包中的数个bytes,看看会发生什么。抵御此类攻击的第一道防线是简单的校验和。一个校验和是一个由封包所有的byte组合而成的一个短整数。发送者计算出封包的校验和并连同封包一起发送给接收者。接收者取得封包并重新计算校验和；如果和发送者的校验和不匹配，就认为封包被破坏了并抛弃之。在计算校验和时需要包含整个封包，包括header,这样接收者才能检测出header是否被破坏了。 一个完美的校验和算法应该能够对封包中的任何字节改动产生不同的值。当然完美的校验和应该too long to be useful，hash函数有着相同的设计目标从而能够产生完美的校验和。单向的hash函数尤其有用，能够把输入变为混乱值，并且逆向重建输入是不可能的。MD5算法经过广泛的检测，被认为是足够快速的并能够胜任游戏使用的算法。其源代码可在网上找到。 这种简单的校验和机制有两个缺点。第一，因为客户端执行文件包含校验和算法代码，攻击者能够逆向工程出此算法，从而可以为任何消息计算校验和。第二，攻击者能够截获封包并在稍后重发，这也被称为封包重发。 封包重发(Packet Replay) 所谓封包重发，指的是那些不怀好意的玩家截获客户端发出的封包(通常使用某种封包嗅探器)，然后多次发送此包。虽然客户端运用定时器检测机制能够阻止正常客户端过快发送命令，比如定时器没每秒最多发出一个指令，那么无论客户端多么频繁地截获玩家的命令(比如玩家疯狂地按键)，这些命令仍会每秒只发送一次。使用封包重发则是非正规渠道，他是在客户端控制之外重新发送封包，所以能够在一秒内发送相同的指令数百次。 系统设计者也许会在服务器端使用同样每秒一次的定时器检测机制防御这种攻击。但是由于有网络延迟，这样做显得不切实际。因为虽然能够检测出大多数封包重发攻击，但是网络延迟可能会使多个正常封包同时到达服务器，这样就会引起合法命令被抛弃。我们当然不想我们的安全方案把合法玩家视为cheater。 为了防范封包重发,每个封包应该包含一些状态信息,以使数据相同的封包也能有不同的位模式。随着发送封包而增长的数字能够担当此任，但此法太容易被攻击者破解。更好的方案是使用状态机为连续封包产生连续ID数。一个快速可信复杂的方法是使用线性同余的随机数产生器(通常在系统库中)。这种产生器工作如下：State = ( State + a ) * b其中a和b都是精心挑选的数字。 发送者和接收者都为连接准备一个随机数发生器。发送一个封包时，发送者产生一个随机数并把它加入封包，同时更新随机数产生器。接收者检查到来封包中的随机数是否和自己随机数发生器匹配；如果不匹配，可以认为封包有问题；匹配则更新随机数发生器以为下一个封包做准备。 此法有两个复杂度。第一是发送者和接收者如何同步状态机，可以用相同的种子开始状态机，但是然后初始的封包流将一直有相同的位模式并且会很容易被破解。取而代之的是，服务器用一个随机的种子值初始化他的状态机并将此值作为第一个消息发给客户端。第二个复杂度是如何保持状态机在通讯过程中同步。在可信连接上，封包绝不会丢失，可以保证同步。然而当封包会丢失或重组，状况有点复杂。如果一个消息丢失了，发送者状态机将比接收者快一步；接着的封包将被拒绝，尽管他们是合法的。一个简单的解决方案是依赖于随每个封包一起发送的一个真正的序列号(大多数游戏包含此号码在消息中，以在不可信transport上提供可信链接)。给定一个序列号，接收者可以判断他的状态机跳了多少步以接获当前封包。如果程序允许无序delivery,旧的状态机将不得不保存给一个无序封包到达时使用。 大多数运行时库提供的rand函数作为一个状态机使用都不够准确因为它的精度太低(许多实现只有15位)并且它显然的选择作为一个源随机数。 其他的技术(Additional Techniques) 理想状况下，两个具有相同payloads的封包应该在bit patterns上尽可能少的暴露相关性，以阻止攻击者对payload进行分析。消除两组数据所有相关性的一个简单方法是用一串随机bits组合他们，使用异或(XOR)操作。想象一下前面所描述的防御封包重发的方案，发送者和接收者已经同步了他们的随机数发生器。因此，发送者能够为每个封包产生一串随机数并把他们异或放进封包payload中；接收者产生同样的一串随机数然后用同样的方法获取原始的payload。两个相同长度的封包的会留给给攻击者一条线索，那就是封包加密了类似的数据。为了进一步阻挡攻击者，封包可以包含一堆随机的”垃圾”数据，此数据只为改变封包长度。垃圾数据的长度通常由另一个状态机决定。发送者检查他的状态机来决定产生多少垃圾数据并将这些随机的bytes插入到即将发送的封包中。接收者简单的忽略这些垃圾数据。增加的垃圾数据进一步隐藏了payload但是耗费更多的带宽。那些受带宽限制的程序，垃圾数据的长度应该比 payload的平均长度更短。 逆向工程(Reverse Engineering) address最困难的问题以及最终任何阻止篡改协议的方法的缺点就是客户端包含完全的加密算法并且总能够被逆向工程。下面的步骤能够用来使逆向工程更困难： 发布的任何代码都不该包含任何符号和调试信息。 不要把对缓冲区加密和解密分别放在他们自己的函数中；应该把它们和一些其他的网络代码放在一起。用可维护性换取安全性这里是值得考虑的。 应该在运行时计算”魔法数”(不如初始化种子),而不要直接把他们的值放在执行文件中。 在每个版本的客户端中都包含良好的加密方法，就算是早期的测试。如果某个版本客户端没有加密，用户就能够记录未加密的封包流，并用对封包payload的了解来破解下一个加密版本。 记住你的目标是让cheating花大代价，而非杜绝cheating。 实现(Implementation) 本文包含一个C++类SecureTransport,此类使用了所有之前描述过的技术。一个SecureTransport对象封装了发送者和接受者间的一个双向连接。对于每个方向，对象维护4个线性同余的随机数发生器作为协议状态机。这些被初始化为static值，服务器把随机数种子作为第一个消息发给客户端。此类像下面这样使用状态机： 包头开始异或成员length。(这是不必要的如果底层协议提供封包长度,比如UDP) 一个消息序列号被用来防止封包重发。 在每个封包中决定垃圾数据的长度。 产生随机bits来异或payload(加密).一个独立的随机数发生器被用来产生实际的垃圾数据。在调试时，把垃圾数据设为一个常量是很有用的。 源码下载地址封装的socket Demo下载地址 写在最后此文引用至网上某一篇论文，出处不详，在这里再次向作者（Andrew Kirmse）表达敬意以及歉意！原文如下：A Network Protocol for Online Games Andrew Kirmse Most encryption schemes assume that a trusted sender and a trusted recipient want to communicate over an untrusted channel.It seems absurd to suggest that the sender could deliberately try to fool the recipient, yet this is exactly the problem facing designers of online games.Some players cannot be trusted, and worse, they have complete access to the encryption algorithm and all communications via the client executable. Under such circumstances we cannot hope to provide completely secure communications, but we can make the attacker’s job more trouble than it’s worth. This article presents some pratical techniques for building and application-level communications protocol for online games. Definitions Protocol design is most interesting in client/server games, where one of more untrusted clients communicate with a trusted central server.(Cleating is certainly also a problem in peer-to-peer games, but because no entity is trusted in such games, the situation is hopeless)The consequences of cheating in a client/server game is high because the server, as the only trusted entity, maintains the game state and verifies all client commands. We consider protocol security features in a client/server system.The client and server communicate by sending packets over a network channel, which might be reliable(typically TCP) or unreliable(UDP). Although clients can also communicate directly with each other, perhaps for chat or voice, we assume that any data that need to be secured are sent only between a client and the server. Each packet contains two parts: the header, containing administrative information, and the payload, containing the actual data we want to communicate. The goal of the network protocol is to deliver the sender’s original payload to the recipient.Any modifications to the sender’s sequence of payloads should be detected.We deal only with delivery of the payload, leaving the details of packet ordering and reliablility to lower levels in the protocol stack. Packet Tampering Most protocol hackers are casual: they change bytes in a packet and see what happens. The first line of defense anainst such attacks is a simple checksum. A checksum is a short number produced by combining every byte of the packet.The sender computes the checksum of the packet and sends both the packet and the checksum to the recipient.The recipient takes the packer and recomputes its checksum;if the computed checksum doesn’t match the checksum from the sender, the packet is corrupt and should be rejected.It’s important to include the entire packet, including the header, in the checksum computation, so that the recipient can detect changes to the header as well as the payload. A perfect checksum computation would produce a different value if any byte of the packet were changed to any other value. A perfect checksum would be too long to be useful, of course, but hash functions have the same design goal and make excellent checksums. Particularly useful are one-way hash functions, which scramble their input to the extent that reconstructing any part of the input from the hash value is impossible for practical purposes. The MD5 algorithm is well tested, publicly available, and fast enough for use in games. A public domain implementation is available online[Plumb93]. There are two weaknesses in this simple checksum mechanism. First, because the client executable contains the checksum computation code, and attacker can reverse engineer the checksum algorithm, and then compute valid checksums for any message. Second, and attacker can capture valid packets and resend them later, and attack known as packet replay. Packet Replay In a packet replay attack, a malicious user captures a packet from the client (typically using a packet sniffer), and sends it multiple times. A common tactic is to use packet replay to perform commands faster than game allows, even if there are timing checks in the client. For example, a client might use a timer to send a certain command to the server at most once per second, no matter how frequently the player issues the command. Using packet replay, a single user might issue the same command hundreds of times per second. A system designer might try to stop this particular attack by putting a similar once-per-second timer check on the server as well. In the face of widely variable network latency,howerer,this defense is impractical.Although it detects most packet replay attacks, varying network delays can make packets bunch together by the time they reach the server, causing legal command sequences to be rejected. We certainly do not want our security scheme to mark law-abiding players as cheaters. To guard against packet replay, each packet should contain some state information, so that even pakcets with identical payloads have different bit pattern. Something as simple as a number that increments with each sent packet would do, although that scheme is too easy for an attacker to figure out. A better answer is to use a state machine to produce successive identifying numbers for successive packets. A fast and resonably complicated method is a liner congruential random number generator of the type typically found in system libraries. Such generators operate as follows:State = ( State + a ) * bwhere a and b are carefully chosen integers. (For a discussion of this generators, see [Knuth98].) The sender and recipient each keep a liner congruential random number generator for their connections. When sending a packet, the sender produces a random number and adds it to the packet, simultaneously stepping its random number generator. The receiver checks the random number in the incomming packet against its generator; if the numbers don’t match, the packet has been tampered with. If the numbers do match, the receiver steps its random number generator to prepare for the next packet. There are two complications with this scheme. The first is how the sender and receiver initially synchronize their state machines.They could each start their state machines with same fixed seed, but then the initial stream of packets would always have the same bit patterns and thus would be vulnerable to analysis.Instead, the server can initialize its state machine with randomly generated seed values and send these to the client in its first message. The second complication is how to keep the state machines synchronized during communication. On a reliable connection, packets are never lost, so synchronization is guaranteed. When packets are dropped or reordered, howerver, the situation becomes more complicated. If a message is lost, the sender’s state machine will have advanced one more step than the receiver’s; subsequent packets will be rejected, even though they are legitimate. A simple solution is to rely on a true sequence number sent with each packet (most games include this number with messages anyway, toprovide a reliable connection over an unreliable trasport).Given a sequence number, the receiver can determine how many times to step its state machine to catch up to the current packet. If the application allows out-of-order delivery, the old state of the state machine will have to be stored for use when an out-of-order packet arrivers later. The rand function provided with most run-time libraries is inappropriate for use as a state machine because of its low precision (many implementations have only 15 bits) and its obvious choice as a source of random numbers. A fast, high-quality random number implementation is given in [Booth97]. Additional Techniques Ideally, two packets with identical payloads should show as little correlation in their bit patterns as possible, to frustrate analysis of the payload. An easy way to remove all correlation betwen two sets of data is to combine them with a sequence of random bits, using the exclusive-or(XOR) operator.Assuming the previous described packet replay defense, the sender and receiver already have synchronized random number generators.Thus,the sender can generate a sequence of random number for each packet and XOR these into the packet payload; the receiver generates the same sequence of numbers and retrieves the original payload in the same way. Even the fact that two packets have the same length can give an attacker a clue that the packets encode similar data. To further frustrate attacks, each packet can contain a variable amout of random “junk” data, meant only to vary the length of the packet. The length of the junk data is determined by yet another synchronized state machine. The sender checks its state machine to determine how much junk to generate and insert that number of random bytes into an outgoing packet. The receiver simply ignores the junk data.Increasing the amount of junk data helps to further hide the payload but costs additional bandwidth. In typical applications in which bandwidth is limited, the average length of junk data should be made small compared to the average payload size. Reverse Engineering The hardest problem to address, and ultimately the downfall of any scheme to stop protocol tampering, is that the client contains the entire encryption algorithm and thus can always be reverse engineered. Some steps you can take to make reverse engineering harder are as follows: Remove all symbols and debugging information from any code released to the public. Don’t isolate buffer encryption and decryption in their own function; instead, combine there with some other network code. This is one area in which it can be worthwhile to trade maintainability for security. Compute “magic numbers” (such as initialization seeds) at run time instead of placing their values directly in the executable. Include a good encryption scheme in every version of the client, even early betas. If any client version lacks encryption, a user can record a stream of unencrypted packets from one client and then use knowledge of the packet payload to help break the encryption in a later version. Remember that your goal is to make cheating prohibitively expensive, not impossible. Implementation The implementation included with this article includes a C++ class SecureTransport that uses all the previously described techniques. A SecureTransport object encapsulates a two-way connection between a sender and a recipient. For each direction, the object maintains four linear congruential random number generators as protocol state machines. These are initialized to static values, with the understanding that the server would send random seeds in its first message to the client. The class uses the state machines as follows: It XORs the length field at the start of the header. (This is unnecessary if the underlying protocol provides a packet length as in UDP.) A message sequence number is used to prevent packet replay. It determines the length of junk data in each packet. It generates random bits to XOR the payload. A separate random number generator is used to generate the actual junk data. During debugging, it is useful to set the junk data to a known constant value. References[Booth97] Booth,Rick,Inner Loops, Addison-Wesley Developers Press, 1997.[Knuth98] Kunth,Donald,The Art of Computer Programming,Volume 2: Seminnmcrical Algorithms, third edition. Addision-Wesley Longman, Inc, 1998[Plumb93] Plumb,Colin,”md5.c” available online at http://src.openresources.com/debian/src/admin/html/s/rpm_2.4.12.orig%20rpm-2.4.12%20lib%20md5.c.html 1993]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数函数]]></title>
    <url>%2F2017%2F05%2F19%2F%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[可变参数函数概述在c++的学习和编码过程中，会遇到某些函数的参数是不确定的；其中最常见的就是printf函数，其原型为int printf( const char* format, ...);它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的（用三个点“…”做参数占位符）,实际调用时可以有以下的形式：printf(&quot;%d&quot;,i);printf(&quot;%s&quot;,s);printf(&quot;the number is %d ,string is:%s&quot;, i, s); 简单的例子下面我们通过2个简单的可变参数的C函数来具体分析： 用最后一个固定参数来确定可变参数的个数1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &quot;stdarg.h&quot;void simple_va_fun(int num, ...)&#123; va_list arg_ptr;//这里写的什么list，（搞得好像是得到可变参数列表头一样）其实它就是个字符指针:char * int nArgValue = 0; va_start(arg_ptr,num); //以最后一个固定参数num的地址为起点确定变参的内存起始地址。 printf(&quot;num:%d, *arg_ptr:%d\n&quot;, num, *arg_ptr);// 这里打印下就会看出，*arg_ptr 跳过了num指向了下一个参数 for (int i = 0; i &lt; num; i++) &#123; nArgValue = va_arg(arg_ptr,int); //得到下一个可变参数的值 printf(&quot;the %d th arg_ptr: %d \n&quot;,i,nArgValue); //输出各参数的值 &#125; va_end(arg_ptr);//结束标志 return;&#125;int main(int argc, char* argv[])&#123; simple_va_fun(2, 200, 201); return 0;&#125; 输出结果为：num:2, *arg_ptr:200the 0 th arg: 200the 1 th arg: 201 最后一个参数用负数作为结束标志123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &quot;stdarg.h&quot;int test(int tmp, ...)&#123; va_list arg_ptr; va_start(arg_ptr, tmp); while(tmp != -1)&#123; tmp = va_arg(arg_ptr, int); printf(&quot;the %d th arg_ptr: %d \n&quot;,*arg_ptr,tmp); &#125; va_end(arg_ptr); return 0;&#125;int main(int argc, char* argv[])&#123; int a = 100, i = 1, j = 2, k = 3, g = -1; printf(&quot;test1:\n&quot;); test(a, i, j, k, g); printf(&quot;test2:\n&quot;); a = 200, i = 11, j = 12, k = 13; test(a, i, j, g); return 0;&#125; 输出结果如下：test1:the 1 th arg_ptr: 1the 2 th arg_ptr: 2the 3 th arg_ptr: 3the -1 th arg_ptr: -1test2:the 11 th arg_ptr: 11the 12 th arg_ptr: 12the -1 th arg_ptr: -1 这个和上面是一样的，唯一不同的是可变参数列表的第一个参数，没有用来当作参数个数，而是把最后一个参数用负数作为结束标志，参数列表第一个参数在这里的作用仅仅是为了得到可变参数列表的起始地址 分析可变参数列表的实现实际上是由几个宏定义组成的，在文件include/stdarg.h中 var_list用于定义某个变量，其实质是typedef char *va_list;//字符指针类型 va_start(ap, tmp)表示开始获取可变参数列表中的第一个参数（…里面的第一个），跳过最后一个固定参数tmp va_arg(ar, type)表示循环获取到可变参数列表中的参数，args指向下一个参数地址，返回的则是当前参数地址，type表示参数类型 var_end(ap)是结束标志 由此可见，当需求中，参数个数无法确定的时候，可以使用可变参数函数，是很方便的。但是我们可以发现，以上所讲的例子🌰上还是有一定的缺陷的，最起码参数的类型就被限定死了，那么或许有人会问，printf函数不就是实现了能够智能识别参数类型的吗？那是因为函数printf是从固定参数format字符串来分析出参数的类型,再调用va_arg的来获取可变参数的。也就是说,你想实现智能识别可变参数的话是要通过在自己的程序里作判断来实现的。 函数变形（智能识别参数类型）综上，可以变形得到下面的函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &quot;stdarg.h&quot;void simple_va_fun(char *fmt, ...)&#123; va_list arg_ptr; int d; char c, *p, *s; va_start(arg_ptr, fmt); //以固定参数的地址为起点确定变参的内存起始地址。 while (*fmt) &#123; if (&apos;%&apos; == *fmt) &#123; switch (*(++fmt)) &#123; case &apos;s&apos;: /* string */ s = va_arg(arg_ptr, char *); printf(&quot;-----%s\n&quot;, s); break; case &apos;d&apos;: /* int */ d = va_arg(arg_ptr, int); printf(&quot;-----%d\n&quot;, d); break; case &apos;c&apos;: /* char */ /* need a cast here since va_arg only takes fully promoted types */ c = (char)va_arg(arg_ptr, int); printf(&quot;-----%c\n&quot;, c); break; default: c = *fmt; printf(&quot;-default---%c\n&quot;, c); &#125; // end of switch &#125; else &#123; c = *fmt; printf(&quot;-else---%c \n &quot;, c); &#125; ++fmt; &#125; va_end(arg_ptr);&#125;int main(int argc, char* argv[])&#123; simple_va_fun(&quot;%s, %d, %c&quot;, &quot;testStr&quot;, 854, &apos;k&apos;); return 0;&#125; 输出结果为：-----testStr-else---,-else--------854-else---,-else--------k 这里采用类似printf函数的方法，在最后一个固定参数传入可变参数的类型，在运行时智能识别参数类型，并获取到参数的值]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的移位预算的意义]]></title>
    <url>%2F2017%2F05%2F19%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%A7%BB%E4%BD%8D%E9%A2%84%E7%AE%97%E7%9A%84%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[最近发现很多地方用到移位、与等运算代替了常用的乘除法。这样做可以从很大程度上提高程序的效率缩短程序运行时间。但是这样做对于我这样的初学者来说一下子不能快速理解，所以在这里记录下一些常用的运算以及他们所代表的含义：给定一个无符号整数n = 15， 它的二进制数为1111，下面我们结合这个数说说各个运算的含义 n &gt;&gt; 1 将n向右移动一位，变为0111 = 7, 表示的数学含义是 n/2 n &lt;&lt; 1 将n向左移动一位，变为11110 = 30，表示的数学含义是 n * 2 n &amp; 0X1 常用语判断n的奇偶性，如果n &amp; 0X1 == 1 说明n的二进制中最后一位是1，即n是奇数 如果 n &amp; 0X1 == 0说明n的二进制位最后一位是0，即n是偶数 n &amp; (n-1) 所得结果是将n的最右边的1去掉 n &amp; (n-1) 统计N的二进制数中1的个数 n | (n-1) 统计N的二进制数中0的个数eg : 求一个数n的二进制位中1的个数 123456int counter = 0;while(n)&#123; ++counter; n = n &amp; (n - 1);&#125; n &amp; (n - 1) == 0 表示n是2的整数次幂n &amp; (n - 1) != 0 表示n不是2的整数次幂]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>